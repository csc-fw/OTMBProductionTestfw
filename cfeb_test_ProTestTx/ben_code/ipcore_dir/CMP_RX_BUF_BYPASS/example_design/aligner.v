///////////////////////////////////////////////////////////////////////////////
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor: Xilinx 
// \   \   \/     Version : 1.8
//  \   \         Application : Virtex-6 FPGA GTX Transceiver Wizard
//  /   /         Filename : aligner.v
// /___/   /\     
// \   \  /  \ 
//  \___\/\___\
//
//
// Module ALIGNER
// Generated by Xilinx Virtex-6 FPGA GTX Transceiver Wizard
// 
// 
// (c) Copyright 2009-2010 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES. 




`timescale 1 ps / 1 ps
`define DELAY #50

module ALIGNER 
(
    output      [7:0]   OVRD_STATE_OUT,     // Delay alignment (override value)
    output              DWE_OUT,            // DRP DWE (for writing override)
    output              LOCK,               // Aligner lock signal
    input       [7:0]   LOOK_INIT,          // First 'h80 offset
    input       [7:0]   LOOK_INCR,          // 'h80 offset increment
    input       [7:0]   WAIT,               // Clock cycles per control state
    input       [2:0]   LOCK_INCR,          // Lock count increment
    input               MONITOR,
    input               DRDY_IN,            // DRP DRDY
    input               ALN_CLK_IN,         // Control FSM clock
    input               ALN_RESET_IN,       // Control FSM reset
    input               DRP_RESET_IN        // DRP reset
 );


//**************************Wire & Reg Declarations***************************

    reg         [7:0]   ovrd_state;
    reg                 dwe;


    reg                 aln_rst_int;       // Internally synchronized aln_reset
    reg                 drp_rst_int;       // Internally synchronized aln_reset
    reg                 sample_int;        // Internally synchronized rusrclk

    reg                 ena;               // Enable FSM action
    reg         [7:0]   wait_ctr;          // FSM wait counter

    reg         [7:0]   lock_cnt_r;
    reg         [4:0]   lock_stable_cnt_r;
    reg                 last_decision_r;

    reg         [1:0]   aln_state;

    wire                drdy;
    wire                aln_clk;
    wire                aln_reset;
    wire                drp_reset;


//*******************************Main Body of Code****************************

    // Assign input and output to the internal signals
    assign OVRD_STATE_OUT = ovrd_state;
    assign DWE_OUT        = dwe;

    assign drdy           = DRDY_IN;
    assign aln_clk        = ALN_CLK_IN;
    assign aln_reset      = ALN_RESET_IN;
    assign drp_reset      = DRP_RESET_IN;

    // Synchronize the asynchronous signals

    reg                 aln_rst_pipe;
    reg                 drp_rst_pipe;
    reg                 sample_pipe;

    always @( posedge aln_clk or posedge aln_reset ) begin
        if ( aln_reset ) begin
            aln_rst_pipe <= `DELAY 1'b1;
            aln_rst_int  <= `DELAY 1'b1;
        end else begin
            aln_rst_pipe <= `DELAY 1'b0;
            aln_rst_int  <= `DELAY aln_rst_pipe;
        end
    end

    always @( posedge aln_clk or posedge drp_reset ) begin
        if ( drp_reset ) begin
            drp_rst_pipe <= `DELAY 1'b1;
            drp_rst_int  <= `DELAY 1'b1;
        end else begin
            drp_rst_pipe <= `DELAY 1'b0;
            drp_rst_int  <= `DELAY drp_rst_pipe;
        end
    end

    always @( posedge aln_clk ) begin
        sample_pipe <= `DELAY MONITOR;
        sample_int  <= `DELAY sample_pipe;
    end

    
    // Generate the enable signal for FSM operation

    always @( posedge aln_clk or posedge aln_rst_int ) begin
        if ( aln_rst_int ) begin
            wait_ctr <= `DELAY 8'd1;
            ena      <= `DELAY 1'b0;
        end else if ( wait_ctr == WAIT ) begin
            wait_ctr <= `DELAY 8'd1;
            ena      <= `DELAY 1'b1;
        end else begin
            wait_ctr <= `DELAY wait_ctr + 8'd1;
            ena      <= `DELAY 1'b0;
        end
    end

    // FSM definition

    `define  ALN_RESET        2'd0
    `define  ALN_LOOK_HIGH    2'd1
    `define  ALN_LOOK_LOW     2'd3
    `define  ALN_TRACK        2'd2

    reg         [7:0]   offset;
    reg         [7:0]   old_offset;
    reg                 updnsw;
    reg                 high_sample;
    reg                 mid_sample;

    always @( posedge aln_clk or posedge aln_rst_int ) begin
        if ( aln_rst_int ) begin
            ovrd_state        <= `DELAY 8'h80;
            aln_state         <= `DELAY `ALN_RESET;
            offset            <= `DELAY LOOK_INIT;
            old_offset        <= `DELAY LOOK_INIT;
            updnsw            <= `DELAY 1'b0;
            high_sample       <= `DELAY 1'b0;
            lock_cnt_r        <= `DELAY 8'h00;
            lock_stable_cnt_r <= `DELAY 5'b00000;
            last_decision_r   <= `DELAY 1'b0;
        end else if ( ! ena ) begin
            // Wait for FSM operation enabled
        end else if ( aln_state == `ALN_RESET ) begin
            ovrd_state  <= `DELAY 8'h80 + offset;
            aln_state   <= `DELAY `ALN_LOOK_HIGH;
            mid_sample  <= `DELAY sample_int;
        end else if ( aln_state == `ALN_LOOK_HIGH ) begin
            ovrd_state  <= `DELAY 8'h80 - offset;
            aln_state   <= `DELAY `ALN_LOOK_LOW;
            offset      <= `DELAY ( offset >= 8'h60 ) ? LOOK_INIT
                                                   : ( offset + LOOK_INCR );
            old_offset  <= `DELAY offset;
            high_sample <= `DELAY sample_int;
        end else if ( aln_state == `ALN_LOOK_LOW ) begin
            if ( ( high_sample ^ sample_int ) |
                 ( high_sample ^ mid_sample ) ) begin

                if ( high_sample ^ mid_sample ) begin
                    ovrd_state  <= `DELAY 8'h80 + old_offset;
                end
                aln_state   <= `DELAY `ALN_TRACK;
                updnsw      <= `DELAY high_sample;
            end else begin

                ovrd_state  <= `DELAY 8'h80 + offset;
                aln_state   <= `DELAY `ALN_LOOK_HIGH;
            end
        end
        else if ( aln_state == `ALN_TRACK ) begin

            // lock_stable_cnt_r counts the number of fsm cycles
            // that the lock_cnt_r is greater than 0; it saturates
            // at 31 and is cleared whenever lock_cnt_r is equal
            // to 0
            if (lock_cnt_r > 0 && lock_stable_cnt_r < 31)
                lock_stable_cnt_r <= lock_stable_cnt_r + 1'b1;
            else if (lock_cnt_r == 0)
                lock_stable_cnt_r <= 0;

            last_decision_r <= sample_int ^ updnsw;

            // check which way to tune (up or down; +/-)
            if ( sample_int ^ updnsw ) begin

                if ( ovrd_state < 8'hff ) begin
                    ovrd_state <= `DELAY ovrd_state + 8'd1;
                end

                if (last_decision_r) begin
                    if (lock_cnt_r > 0) begin
                      lock_cnt_r <= lock_cnt_r - 1'b1;
                    end
                end
                else if (lock_cnt_r < (256 - LOCK_INCR))
                    lock_cnt_r <= lock_cnt_r + LOCK_INCR;
            end

            else begin
                if ( ovrd_state > 8'h00 ) begin
                    ovrd_state <= `DELAY ovrd_state - 8'd1;
                end

                if (~last_decision_r) begin
                    if (lock_cnt_r > 0) begin
                        lock_cnt_r <= lock_cnt_r - 1'b1;
                    end
                end
                else if (lock_cnt_r < (256 - LOCK_INCR))
                    lock_cnt_r <= lock_cnt_r + LOCK_INCR;
            end
        end
    end

    // This is the lock signal for the delay aligner module
    assign LOCK = lock_stable_cnt_r[4];

    // DRP control
    reg prev_drp_rst_int;

    always @( posedge aln_clk or posedge drp_rst_int ) begin
        if ( drp_rst_int ) begin
            prev_drp_rst_int <= `DELAY 1'b1;
            dwe              <= `DELAY 1'b0;
        end else if ( prev_drp_rst_int ) begin
            prev_drp_rst_int <= `DELAY 1'b0;
            dwe              <= `DELAY 1'b1;
        end else begin
            dwe              <= `DELAY drdy;
        end
    end

endmodule  // aligner

