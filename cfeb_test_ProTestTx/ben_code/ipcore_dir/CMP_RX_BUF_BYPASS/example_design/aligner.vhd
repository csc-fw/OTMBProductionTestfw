------------------------------------------------------------------------------
--   ____  ____ 
--  /   /\/   /
-- /___/  \  /    Vendor: Xilinx 
-- \   \   \/     Version : 1.8
--  \   \         Application : Virtex-6 FPGA GTX Transceiver Wizard 
--  /   /         Filename : aligner.vhd
-- /___/   /\     
-- \   \  /  \ 
--  \___\/\___\
--
--
-- Module ALIGNER
-- Generated by Xilinx Virtex-6 FPGA GTX Transceiver Wizard
-- 
-- 
-- (c) Copyright 2009-2010 Xilinx, Inc. All rights reserved.
-- 
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
-- 
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
-- 
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
-- 
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES. 



library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;
library UNISIM;
use UNISIM.VCOMPONENTS.ALL;

entity ALIGNER is 
port (
             OVRD_STATE_OUT : out std_logic_vector(7 downto 0);     --Delay alignment (override value)
             DWE_OUT        : out std_logic;                        --DRP DWE (for writing override)
             LOCK           : out std_logic;                        --Aligner lock signal
             LOOK_INIT      : in std_logic_vector(7 downto 0);      --First 'h80 offset
             LOOK_INCR      : in std_logic_vector(7 downto 0);      --'h80 offset increment
             WAIT_IN        : in std_logic_vector(7 downto 0);      --Clock cycles per control state
             LOCK_INCR      : in std_logic_vector(2 downto 0);      --Lock count increment
             MONITOR        : in std_logic;
             DRDY_IN        : in std_logic;      --DRP DRDY
             ALN_CLK_IN     : in std_logic;      --Control FSM clock
             ALN_RESET_IN   : in std_logic;      --Control FSM reset
             DRP_RESET_IN   : in std_logic       --DRP reset
 );
end ALIGNER;


architecture RTL of ALIGNER is
    --FSM definition

    constant  ALN_RESET_FSM    : std_logic_vector (1 downto 0) := "00" ;
    constant  ALN_LOOK_HIGH    : std_logic_vector (1 downto 0) := "01" ;
    constant  ALN_LOOK_LOW     : std_logic_vector (1 downto 0) := "11" ;
    constant  ALN_TRACK        : std_logic_vector (1 downto 0) := "10" ;
  
    constant  DLY              : time := 50 ps;
--**************************Signal Declarations***************************

    signal                 ovrd_state        : std_logic_vector (7 downto 0);
    signal                 dwe               : std_logic;


    signal                 aln_rst_int       : std_logic;       --Internally synchronized aln_reset
    signal                 drp_rst_int       : std_logic;       --Internally synchronized aln_reset
    signal                 sample_int        : std_logic;        --Internally synchronized rusrclk

    signal                 ena               : std_logic;               --Enable FSM action
    signal                 wait_ctr          : std_logic_vector (7 downto 0);          --FSM wait counter

    signal                 lock_cnt_r        : std_logic_vector (7 downto 0);
    signal                 lock_stable_cnt_r : std_logic_vector (4 downto 0);
    signal                 last_decision_r   : std_logic;

    signal                 aln_state         : std_logic_vector (1 downto 0);

    signal                drdy               : std_logic;
    signal                aln_clk            : std_logic;

    signal                aln_reset          : std_logic;
    signal                drp_reset          : std_logic;

    --Synchronize the asynchronous signals

    signal                 aln_rst_pipe : std_logic;
    signal                 drp_rst_pipe : std_logic;
    signal                 sample_pipe : std_logic;

    signal                 offset      : std_logic_vector(7 downto 0);
    signal                 old_offset  : std_logic_vector(7 downto 0);
    signal                 updnsw      : std_logic;
    signal                 high_sample : std_logic;
    signal                 mid_sample  : std_logic;

    --DRP control
    signal prev_drp_rst_int : std_logic;
--*******************************Main Body of Code****************************


begin
    --Assign input and output to the internal signals
     OVRD_STATE_OUT <= ovrd_state;
     DWE_OUT        <= dwe;

     drdy           <= DRDY_IN;
     aln_clk        <= ALN_CLK_IN;
     aln_reset      <= ALN_RESET_IN;
     drp_reset      <= DRP_RESET_IN;

    --This is the lock signal for the delay aligner module
     LOCK <= lock_stable_cnt_r(4);


    process (aln_clk,aln_reset) begin
      if(aln_reset = '1') then
        aln_rst_pipe <= '1' after DLY;
        aln_rst_int  <= '1' after DLY;
      elsif(aln_clk'event and aln_clk = '1') then
        aln_rst_pipe <= '0' after DLY;
        aln_rst_int  <= aln_rst_pipe after DLY;
       end if;
    end process;


    process (aln_clk,drp_reset) begin
      if(drp_reset = '1') then
        drp_rst_pipe <= '1' after DLY;
        drp_rst_int  <= '1' after DLY;
      elsif(aln_clk'event and aln_clk = '1') then
        drp_rst_pipe <= '0' after DLY;
        drp_rst_int  <= drp_rst_pipe after DLY;
       end if;
    end process;


    process(aln_clk) begin
      if(aln_clk'event and aln_clk = '1') then
        sample_pipe <= MONITOR after DLY;
        sample_int  <= sample_pipe after DLY;
       end if;
    end process;
    --Generate the enable signal for FSM operation

    process(aln_clk,aln_rst_int) begin
      if(aln_rst_int = '1') then
        wait_ctr <= x"01" after DLY;
        ena      <= '0' after DLY;
      elsif(aln_clk'event and aln_clk = '1') then
        if(wait_ctr = WAIT_IN ) then
          wait_ctr <= x"01" after DLY;
          ena      <= '1' after DLY;
        else 
          wait_ctr <= wait_ctr + '1' after DLY ;
          ena      <= '0' after DLY;
         end if;
       end if;
    end process;


    process (  aln_clk ,  aln_rst_int , LOOK_INIT) begin
        if ( aln_rst_int = '1' ) then
            ovrd_state        <= x"80"  after DLY;
            aln_state         <= ALN_RESET_FSM  after DLY;
            offset            <= LOOK_INIT  after DLY;
            old_offset        <= LOOK_INIT   after DLY;
            updnsw            <= '0' after DLY;
            high_sample       <= '0' after DLY;
            lock_cnt_r        <= x"00"  after DLY;
            lock_stable_cnt_r <= b"00000"  after DLY;
            last_decision_r   <= '0' after DLY;
        elsif( aln_clk'event and aln_clk = '1') then
          if ( ena = '0' ) then
              --Wait for FSM operation enabled
          elsif  ( aln_state = ALN_RESET_FSM ) then
              ovrd_state  <= x"80" + offset  after DLY;
              aln_state   <= ALN_LOOK_HIGH  after DLY;
              mid_sample  <= sample_int  after DLY;
          elsif  ( aln_state = ALN_LOOK_HIGH ) then
              ovrd_state  <= x"80" - offset  after DLY;
              aln_state   <= ALN_LOOK_LOW  after DLY;
              if( offset >= x"60") then
                offset <= LOOK_INIT after DLY;
              else 
                offset <= offset + LOOK_INCR after DLY;
              end if;
              old_offset  <= offset  after DLY;
              high_sample <= sample_int  after DLY;
          elsif  ( aln_state = ALN_LOOK_LOW ) then
              if (( ( high_sample xor  sample_int ) or ( high_sample xor  mid_sample ) ) = '1') then
                  if ( (high_sample xor mid_sample) = '1' ) then
                      ovrd_state  <= x"80" + old_offset  after DLY;
                   end if;
                  aln_state   <= ALN_TRACK  after DLY;
                  updnsw      <= high_sample  after DLY;
              else 

                  ovrd_state  <= x"80" + offset  after DLY;
                  aln_state   <= ALN_LOOK_HIGH  after DLY;
               end if;
          elsif  ( aln_state = ALN_TRACK ) then

              --lock_stable_cnt_r counts the number of fsm cycles
              --that the lock_cnt_r is greater than 0; it saturates
              --at 31 and is cleared whenever lock_cnt_r is equal
              --to 0
              if ((lock_cnt_r > 0) and  ( lock_stable_cnt_r < 31) ) then
                  lock_stable_cnt_r <= lock_stable_cnt_r + 1;
              elsif (lock_cnt_r = 0) then
                  lock_stable_cnt_r <= b"00000";
              end if;
              last_decision_r <= sample_int xor updnsw;

              --check which way to tune (up or down; +/-)
              if (( sample_int xor updnsw) = '1' ) then

                  if ( ovrd_state < x"ff" ) then
                      ovrd_state <= ovrd_state + x"01"  after DLY;
                   end if;

                  if (last_decision_r = '1') then
                      if (lock_cnt_r > 0) then
                        lock_cnt_r <= lock_cnt_r - x"01";
                       end if;
                  elsif (lock_cnt_r < (x"100" - LOCK_INCR)) then
                      lock_cnt_r <= lock_cnt_r + LOCK_INCR;
                  end if;      
              else 
                  if ( ovrd_state > x"00" ) then
                      ovrd_state <= ovrd_state - x"01"  after DLY;
                   end if;

                  if ( last_decision_r = '0') then
                      if (lock_cnt_r > 0) then
                          lock_cnt_r <= lock_cnt_r - x"01";
                       end if;
                  elsif (lock_cnt_r < (x"100" - LOCK_INCR)) then
                      lock_cnt_r <= lock_cnt_r + LOCK_INCR;
                   end if;      
               end if;
           end if;
         end if; --else of if( aln_clk'event and aln_clk = '1') then
    end process;




    process (aln_clk,drp_rst_int) begin
      if(drp_rst_int = '1') then
        prev_drp_rst_int <= '1' after DLY;
        dwe              <= '0' after DLY;
      elsif(aln_clk'event and aln_clk = '1') then
        if(prev_drp_rst_int = '1') then
          prev_drp_rst_int <= '0' after DLY;
          dwe              <= '1' after DLY;
        else 
          dwe              <= drdy  after DLY;
         end if;
       end if;
    end process;

end RTL;  

